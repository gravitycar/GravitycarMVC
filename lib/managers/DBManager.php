<?php
namespace Gravitycar\lib\managers;
/**
 * DBManager
 *
 * Class for all things database for any module:
 * 
 * - Creating tables
 * - Dropping tables
 * - Altering tables.
 * - Selects, Inserts, Updates and Deletes
 *
 * This class should generate the SQL statements above based on the propdefs for any
 * module. A module will pass in its propdefs and various methods of this class are
 * expected to return executable SQL, or execute said SQL.
 */
class DBManager extends \Gravitycar\lib\abstracts\Singleton
{
    /** @var string $userName
    The user name to log into the database. */
    private $userName = '';
    
    /** @var string $password 
    The password to use to log into the database */
    private $password = '';
    
    /** @var string $hostName
    The name/IP address of the database host machine */
    private $hostName = '';
    
    /** @var string $databaseName
    The name of the database */
    private $databaseName = '';
    
    /** @var array $generatedIDs
     An array of ID's generated by this class (during this instantiation) */
    private $generatedIDs = array();
    
    /** @var mysqli 
    The database object */
    private $mysqli = null;
    
    public function init()
    {
        parent::init();
        return $this->connect();
    }
    
    public function connect($dbAlreadyExists = true)
    {
        $this->mysqli = mysqli_init();
        $this->userName = $this->cfg->get('db.user');
        $this->password = $this->cfg->get('db.pass');
        $this->hostName = $this->cfg->get('db.host');
        $this->databaseName = $dbAlreadyExists ? $this->cfg->get('db.name') : '';
        
        try {
            $connectOK = @$this->mysqli->real_connect($this->hostName, 
                                       $this->userName, 
                                       $this->password, 
                                       $this->databaseName);
        } catch (Exception $e) {
            $connectOK = false;
        }
            
        if (!$connectOK) {
            $errorMsg = 'Connect Error (' . mysqli_connect_errno() . ') ' . mysqli_connect_error(); 
            $this->errMgr->error($errorMsg);
            $this->log->error($errorMsg);
            
            // database error indicates DB does not exist - try to connect without a
            // DB name. This should only happen on initial setup of the application.
            if (mysqli_connect_errno() == '1049') {
                $connectOK = $this->connectWithoutDB();
            }
            
            //die($errorMsg);
        }
        
        return $connectOK;
    }
    
    
    /**
     * connectWithoutDB()
     *
     * Creates a database connection to use when the database doesn't yet exist.
     *
     * @return bool - true if connection succeeds, false otherwise.
     */
    public function connectWithoutDB()
    {
        $dbAlreadyExists = false;
        return $this->connect($dbAlreadyExists);
    }
    
    
    public function fetchByAssoc($result)
    {
        return $result->fetch_assoc();
    }
    
    
    /**
     * query()
     *
     * Sends an sql query to the database.
     *
     * NOTE - it's NOT this method's job to scrub the user data in the SQL!
     * That is the job of whatever method PASSES the SQL to this method. 
     * Individual pieces of user-submitted data should be scrubbed invidually 
     * DBManager::formatDatum() (which relies partially on mysqli::real_escape_string().
     *
     * @param string $sql - the sql you want to execute against the database.
     * @return mixed - either a mysqli ResultSet or boolean, true for successful
     *  query, false otherwise.
     */
    public function query($sql)
    {
        $result = $this->mysqli->query($sql);
        
        if ($result === false) {
            $this->errMgr->error("This query failed!\n$sql");
        }
        
        if ($this->mysqli->error) {
            $this->errMgr->error($this->mysqli->error);
        }
        
        return $result;
    }
    
    
    /**
     * getMySQLType()
     *
     * Looks at the datatype from the propdefs for a particular field and returns the
     * appropriate MySQL data type value for creating/altering tables.
     *
     * @param hash $propdefs - the definitions for a single field (not the whole
     *  propdefs array for the module).
     * @return string - a mysql datatype name.
     */
    public function getMySQLType($propdefs)
    {
        $type = $propdefs['datatype'];
        $mysqlType = '';
        switch ($type) {
            case "bool":
                $mysqlType = 'bool';
            break;
            
            case "float":
            case "numeric":
                $mysqlType = 'double';
            break;
            
            case "datetime":
                $mysqlType = 'datetime';
            break;
                
            case "date":
                $mysqlType = 'date';
            break;
            
            case "integer":
            case "int":
                $mysqlType = 'int';
            break;
            
            case "string":
                $maxLength = IsSet($propdefs['len']) ? IsSet($propdefs['len']) : 255;
                if ($maxLength <= 255) {
                    $mysqlType = 'tinytext';
                } else if ($maxLength <= 65535) {
                    $mysqlType = 'text';
                } else {
                    $mysqlType = 'longtext';
                }
                
                if (IsSet($propdefs['isPrimary']) && $propdefs['isPrimary'] == true) {
                    $mysqlType = "varchar({$propdefs['len']})";
                }
            break;
            
            case "array":
                $mysqlType = 'text';
            break;
            
            case "object":
                $mysqlType = 'blob';
            break;
            
            default:
                $mysqlType = 'text';
            break;
        }
        
        return $mysqlType;
    }
    
    
    /**
     * generateDBID()
     *
     * Creates a (probably) unique id for a table row. 
     *
     * @param int $idLength - how long the ID can be (typically 16 characters).
     * @return string - a hex string $idLength characters long.
     */
    public function generateDBID($idLength = 16)
    {
        $bytes = openssl_random_pseudo_bytes($idLength);
        $hex = substr(bin2hex($bytes), 0, $idLength);
        $this->generatedIDs[] = $hex;
        return $hex;
    }
    
    
    /**
     * getLastInsertID()
     * 
     * Returns the last id generated by this class (during the current instantiation).
     * 
     * @return string - the last ID generated.
     */
    public function getLastInsertID()
    {
    	$lastIndex = count($this->generatedIDs) - 1;
    	return $this->generatedIDs[$lastIndex];
    }
    
    
    /**
     * propertyIsInDB()
     *
     * Returns true if the passed in property definition array indicates that
     * the property's value should be stored in the database, false if not.
     *
     * @param hash $defs - a property definition hash
     * @return bool - true if property is stored in db, false otherwise.
     */
    public function propertyIsInDB($defs)
    {
        if (!IsSet($defs['source'])) {
            return false;
        }
        
        if ($defs['source'] != 'db') {
            return false;
        }
        
        if ($defs['datatype'] == 'relationship') {
            return false;
        }
        
        return true;
    }
    
    
    
    public function getTableDescription($graviton)
    {
        $tableData = array();
        $sql = "describe {$graviton->tableName}";
        $result = $this->query($sql);
        while ($row = $this->fetchByAssoc($result)) {
            $tableData[$row['Field']] = $row;
        }
        return $tableData;
    }
    
    
    /**
     * formatDatum()
     *
     * Takes a property definition and a value to be assigned to the property
     * represented by the definition, and formats it for storage in the db.
     * Mostly this means cleaning the value with real_escape_string(), quoting
     * string values and concatenating arrays.
     *
     * @param hash $defs - the property definitions for a property.
     * @param mixed $datum - a value to assign to the property.
     * @return mixed - a value safe to store in the DB.
     */
    public function formatDatum($defs, $datum)
    {
        if (is_scalar($datum)) {
            $cleanDatum = $this->mysqli->real_escape_string($datum);
        } else {
            $this->log->debug(var_export($datum, true));
        }
        
        if (is_array($datum)) {
            $tempDefs = array('datatype' => 'string');
            foreach ($datum as $value) {
                $cleanDatum[] = $this->formatDatum($tempDefs, $value);
            }
        }
        
        switch ($defs['datatype'])
        {
            case "bool":
            case "float":
            case "numeric":
            case "int":
                return $cleanDatum;
            break;
            
            case "array":
                return "(" . implode(", ", $cleanDatum) . ")";
            break;
            
            default:
                return "'" . str_replace("'", "\'", $cleanDatum) . "'";
            break;
        }
    }
    
    
    public function generateSQLSelect($graviton, $data = array())
    {
        if (isset($data['fields'])) {
            $fields = implode(', ', $data['fields']);
        } else {
            $fields = implode(', ', $graviton->getListFields());
        }
        
        if (isset($data['where'])) {
            $where  = ' where ' . $this->generateWhereClause($graviton, $data['where']);
        } else {
            $where = '';
        }
        
        $sql = "select $fields from {$graviton->table} $where";
        return $sql;
    }
    
    
    public function generateSQLInsert($graviton, $data)
    {

        $sql = "INSERT INTO {$graviton->table} ";
        $clauses = array();
        foreach ($graviton->propdefs as $fieldName => $defs) {
            if (!$this->propertyIsInDB($defs)) {
                continue;
            }
            $dataFieldName = $fieldName;
            if ($defs['required'] && empty($data[$dataFieldName])) {
                if (!empty($defs['defaultvalue'])) {
                    $data[$dataFieldName] = $defs['defaultvalue'];
                } else {
                    $this->errMgr->error("Cannot insert {$graviton->moduleName} - $fieldName is empty and has no default!");
                    return '';
                }
            }
            
            $clauses[$fieldName] = $this->formatDatum($defs, $data[$dataFieldName]);
        }
        
        $sql .= '(' . implode(', ', array_keys($clauses)) . ')';
        $sql .= ' VALUES (' . implode(', ', $clauses) . ')';
        return $sql;
    }
    
    
    public function generateSQLUpdate($graviton, $data)
    {
        $sql = "UPDATE {$graviton->table} SET ";
        $clauses = array();
        $graviton->id = $data["id"];
        foreach ($graviton->propdefs as $fieldName => $defs) {
            if (!$this->propertyIsInDB($defs)) {
                continue;
            }
            
            $dataFieldName = $fieldName;
            
            if ($defs['required'] && empty($data[$dataFieldName])) {
                if (!empty($defs['defaultvalue'])) {
                    $data[$dataFieldName] = $defs['defaultvalue'];
                } else {
                    $this->errMgr->error("Cannot update {$graviton->moduleName} - $fieldName is empty and has no default!");
                    return '';
                }
            }
            
            $cleanValue = $this->formatDatum($defs, $data[$dataFieldName]);
            $clauses[] = "$fieldName = $cleanValue";
        }
        
        $searchParams = $this->generateSearchParam($graviton, 'id');
        $whereClause = $this->generateWhereClause($graviton, $searchParams);
        $sql .= implode(', ', $clauses) . " WHERE $whereClause";
        return $sql;
    }
    
    
    public function generateSQLDelete($graviton)
    {
        $sql = "DELETE FROM {$graviton->table} ";
        
        $searchParams = $this->generateSearchParam($graviton, 'id');
        $whereClause = $this->generateWhereClause($graviton, $searchParams);
        
        $sql .= " WHERE $whereClause";
        return $sql;
    }
    
    
    public function generateSearchParam($graviton, $searchColumns, $searchTerms=array(), $exactMatch=true)
    {
        $params = array();
        if (!is_array($searchColumns)) {
            $searchColumns = array($searchColumns);
        }
        
        foreach ($searchColumns as $column) {
            $params[$column] = array();
            $defs = $graviton->getPropDef($column);
            if (empty($defs)) {
                $this->log->error("$column is not a valid property of a {$graviton->moduleName} - skipping as a search param.");
                continue;
            }
            
            if (!IsSet($defs['source']) || $defs['source'] != 'db') {
                $this->log->error("$column is not a database value for a {$graviton->moduleName} - skipping as a search param.");
                continue;
            }
            
            if (!is_array($searchTerms) || !IsSet($searchTerms[$column])) {
                
                $searchTerms[$column] = $graviton->$column;
            }
            
            if (!IsSet($searchTerms[$column])) {
                $this->log->error("No search term for '{$graviton->moduleName}.$column' provided - skipping as a search param.");
                continue;
            }
            
            $params[$column]['value'] = $searchTerms[$column];
            
            if ($defs['datatype'] == 'array') {
                $params[$column]['operator'] = 'in';
            } else if ($exactMatch !== true) {
                $params[$column]['operator'] = 'like';
            }
        }
        
        return $params;
    }
    
    
    /**
     * generateWhereClause()
     *
     * Creates a where clause (without the word "where" - you supply that) based 
     * on pairs of column names mapped to hashes of search term information. Here
     * are  a couple of examples:
     *
     * searchParams['id'] => array('value' => '12345678', 'operator' => '=')
     * searchParams['id'] => array('value' => array('12345678', 'ABCDEFGH'), 'operator' => 'in')
     *
     * The resulting where clause should be suitable for updates, deletes and selects.
     * This method is supposed to be for relatively simple statements - where clauses with
     * deeply nested logic are probably best created manually rather than with 
     * this method.
     *
     * @param Graviton $graviton - a graviton object.
     * @param hash $searchParams - which columns/values you're search for, and which operator
     *  to use.
     * @param string $and_or - Whether to join your various sub-clauses with an AND
     *  or an OR. Default is ' AND '.
     * @return string - an SQL where clause.
     */
    public function generateWhereClause($graviton, $searchParams, $and_or = ' AND ')
    {
        /*
        searchParams['id']
        */
        $clause = '';
        $pairs = array();
        foreach ($searchParams as $columnName => $termData) {
            $defs = $graviton->getPropDef($columnName);
            $formattedValue = $this->formatDatum($defs, $termData['value']);
            $operator = empty($termData['operator']) ? '=' : $termData['operator'];
            $columnName = "{$graviton->table}.$columnName";
            $pairs[] = "$columnName $operator $formattedValue";
        }
        $clause = implode($and_or, $pairs);
        return $clause;
    }
}
